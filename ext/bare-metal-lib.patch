diff --git a/examples/mss-usb/mpfs-usb-host-hid/mpfs-usb-host-hid renode-emulation-platform.launch b/examples/mss-usb/mpfs-usb-host-hid/mpfs-usb-host-hid renode-emulation-platform.launch
index d0da9dd..5d755cf 100644
--- a/examples/mss-usb/mpfs-usb-host-hid/mpfs-usb-host-hid renode-emulation-platform.launch	
+++ b/examples/mss-usb/mpfs-usb-host-hid/mpfs-usb-host-hid renode-emulation-platform.launch	
@@ -3,9 +3,6 @@
     <mapAttribute key="org.eclipse.debug.core.environmentVariables">
         <mapEntry key="RENODE_CUSTOM_SCRIPTS" value="${env_var:SC_INSTALL_DIR}/renode-microchip-mods"/>
     </mapAttribute>
-    <listAttribute key="org.eclipse.debug.ui.favoriteGroups">
-        <listEntry value="org.eclipse.ui.externaltools.launchGroup"/>
-    </listAttribute>
     <stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${env_var:RENODE_BINARY_LAUNCHER}"/>
     <stringAttribute key="org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS" value="${env_var:RENODE_BINARY_ARGUMENT} ${project_loc}/renode/mpfs-usb-platform.resc"/>
     <stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${eclipse_home}../renode/bin"/>
diff --git a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.c b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.c
index c5b830e..0d2ec39 100644
--- a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.c
+++ b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.c
@@ -1,4 +1,8 @@
 /*******************************************************************************
+ * See LICENSE for license details.
+ * Modifications copyright (C) 2021 Hex Five Security, Inc.
+ */
+ /*******************************************************************************
  * Copyright 2020 Microchip Corporation.
  *
  * SPDX-License-Identifier: MIT
@@ -186,6 +190,7 @@ MSS_MAC_init
     ASSERT((this_mac == &g_mac0) || (this_mac == &g_mac1) || (this_mac == &g_emac0) || (this_mac == &g_emac1));
     instances_init(this_mac, cfg);
 
+#if 0 /* Hex Five */
     /*
      * Always reset GEM if the pMAC is selected for init but not if eMAC
      * The pMAC should always be initialised first followed by the eMAC so this
@@ -226,6 +231,7 @@ MSS_MAC_init
         /* Take MAC out of reset. */
         SYSREG->SOFT_RESET_CR &= (uint32_t)~4U;
     }
+#endif
 
     /*
      * Disable all queues.
@@ -5522,14 +5528,14 @@ static void instances_init(mss_mac_instance_t *this_mac, mss_mac_cfg_t *cfg)
             this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC0_BASE;
             this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC0_BASE;
 
-            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM0_ABP_BIT;
+/*            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM0_ABP_BIT; */ /* Hex Five */
         }
         else
         {
             this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC0_BASE_HI;
             this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC0_BASE_HI;
 
-            SYSREG->APBBUS_CR |= MSS_MAC_GEM0_ABP_BIT;
+/*            SYSREG->APBBUS_CR |= MSS_MAC_GEM0_ABP_BIT;  */ /* Hex Five */
         }
 
         if(0U != this_mac->use_local_ints)
@@ -5568,14 +5574,14 @@ static void instances_init(mss_mac_instance_t *this_mac, mss_mac_cfg_t *cfg)
             this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC1_BASE;
             this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC1_BASE;
 
-            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM1_ABP_BIT;
+/*            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM1_ABP_BIT; */ /* Hex Five */
         }
         else
         {
             this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC1_BASE_HI;
             this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC1_BASE_HI;
 
-            SYSREG->APBBUS_CR |= MSS_MAC_GEM1_ABP_BIT;
+/*            SYSREG->APBBUS_CR |= MSS_MAC_GEM1_ABP_BIT; */ /* Hex Five */
         }
 
         if(0U != this_mac->use_local_ints)
@@ -5620,7 +5626,7 @@ static void instances_init(mss_mac_instance_t *this_mac, mss_mac_cfg_t *cfg)
             this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC0_BASE;
             this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC0_BASE;
 
-            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM0_ABP_BIT;
+/*            SYSREG->APBBUS_CR &= ~MSS_MAC_GEM0_ABP_BIT; */ /* Hex Five */
         }
         else
         {
@@ -5659,14 +5665,14 @@ static void instances_init(mss_mac_instance_t *this_mac, mss_mac_cfg_t *cfg)
                 this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC1_BASE;
                 this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC1_BASE;
 
-                SYSREG->APBBUS_CR &= ~MSS_MAC_GEM1_ABP_BIT;
+ /*               SYSREG->APBBUS_CR &= ~MSS_MAC_GEM1_ABP_BIT; */ /* Hex Five */
             }
             else
             {
                 this_mac->mac_base    = (MAC_TypeDef  *)MSS_MAC1_BASE_HI;
                 this_mac->emac_base   = (eMAC_TypeDef *)MSS_EMAC1_BASE_HI;
 
-                SYSREG->APBBUS_CR |= MSS_MAC_GEM1_ABP_BIT;
+ /*               SYSREG->APBBUS_CR |= MSS_MAC_GEM1_ABP_BIT; */ /* Hex Five */
             }
 
             if(0U != this_mac->use_local_ints)
diff --git a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.h b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.h
index a11bb22..3777b42 100644
--- a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.h
+++ b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_mac.h
@@ -337,7 +337,7 @@ extern "C" {
 #if (MSS_MAC_QUEUE_COUNT >= 2)
 #define MSS_MAC_MAX_PACKET_SIZE                 MSS_MAC_JUMBO_MAX
 #else
-#define MSS_MAC_MAX_PACKET_SIZE                 MSS_MAC_JUMBO_MAX
+#define MSS_MAC_MAX_PACKET_SIZE                 1536 /* Hex Five MSS_MAC_JUMBO_MAX */
 #endif
 #endif
 
diff --git a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_registers.h b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_registers.h
index 8dd193b..8f38cdc 100644
--- a/src/platform/drivers/mss_ethernet_mac/mss_ethernet_registers.h
+++ b/src/platform/drivers/mss_ethernet_mac/mss_ethernet_registers.h
@@ -22,7 +22,7 @@ extern "C" {
 /*----------------------------------------------------------------------------*/
 /*----------------------------------- MAC -----------------------------------*/
 /*----------------------------------------------------------------------------*/
-#define __I  const volatile
+#define __I  volatile const
 #define __O  volatile
 #define __IO volatile
 
diff --git a/src/platform/mpfs_hal/common/mss_mtrap.c b/src/platform/mpfs_hal/common/mss_mtrap.c
index 150a449..3672e72 100644
--- a/src/platform/mpfs_hal/common/mss_mtrap.c
+++ b/src/platform/mpfs_hal/common/mss_mtrap.c
@@ -1,10 +1,6 @@
 /*******************************************************************************
- * Copyright 2019-2020 Microchip FPGA Embedded Systems Solutions.
- *
- * SPDX-License-Identifier: MIT
- *
- * MPFS HAL Embedded Software
- *
+ * See LICENSE for license details.
+ * Modifications copyright (C) 2021 Hex Five Security, Inc.
  */
 
 /***************************************************************************
@@ -32,6 +28,13 @@ void pmp_trap(uintptr_t * regs, uintptr_t mcause, uintptr_t mepc);
 void trap_from_machine_mode(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc);
 void bad_trap(uintptr_t* regs, uintptr_t dummy, uintptr_t mepc);
 
+void handle_m_trap_h0(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h1(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h2(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h3(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap_h4(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+void handle_m_trap(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc); /* Hex Five mod */
+
 
 void bad_trap(uintptr_t* regs, uintptr_t dummy, uintptr_t mepc)
 {
@@ -748,34 +751,65 @@ void trap_from_machine_mode(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc)
     }
     else
     {
-        uint32_t i;
-        while(1)
-        {
-            /* wait for watchdog */
-            i++;        /* added some code as SC debugger hangs if in loop doing nothing */
-            if(i == 0x1000U)
-            {
-                i = 0U;
-            }
+
+        switch(read_csr(mhartid)) {
+        case 0U: handle_m_trap_h0(regs, mcause, mepc); break;
+        case 1U: handle_m_trap_h1(regs, mcause, mepc); break;
+        case 2U: handle_m_trap_h2(regs, mcause, mepc); break;
+        case 3U: handle_m_trap_h3(regs, mcause, mepc); break;
+        case 4U: handle_m_trap_h4(regs, mcause, mepc); break;
+        default: handle_m_trap(regs, mcause, mepc);
         }
-        switch(mcause)
-        {
 
-            case CAUSE_LOAD_PAGE_FAULT:
-                break;
-            case CAUSE_STORE_PAGE_FAULT:
-                break;
-            case CAUSE_FETCH_ACCESS:
-                break;
-            case CAUSE_LOAD_ACCESS:
-                break;
-            case CAUSE_STORE_ACCESS:
-                break;
-            default:
-                bad_trap(regs, dummy, mepc);
-                break;
+    }
+
+}
+
+__attribute__((weak)) void handle_m_trap_h0(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h1(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h2(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h3(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+__attribute__((weak)) void handle_m_trap_h4(uintptr_t * regs, uintptr_t dummy, uintptr_t mepc){
+    handle_m_trap(regs, dummy, mepc);
+}
+
+void handle_m_trap(uintptr_t * regs, uintptr_t mcause, uintptr_t mepc) /* Hex Five mod */
+{
+    uint32_t i;
+    while(1)
+    {
+        /* wait for watchdog */
+        i++;        /* added some code as SC debugger hangs if in loop doing nothing */
+        if(i == 0x1000U)
+        {
+            i = 0U;
         }
     }
+    switch(mcause)
+    {
+
+        case CAUSE_LOAD_PAGE_FAULT:
+            break;
+        case CAUSE_STORE_PAGE_FAULT:
+            break;
+        case CAUSE_FETCH_ACCESS:
+            break;
+        case CAUSE_LOAD_ACCESS:
+            break;
+        case CAUSE_STORE_ACCESS:
+            break;
+        default:
+            bad_trap(regs, mcause, mepc);
+            break;
+    }
 }
 
 #ifdef __cplusplus
diff --git a/src/platform/mpfs_hal/startup_gcc/mss_entry.S b/src/platform/mpfs_hal/startup_gcc/mss_entry.S
index 9e049de..3adea13 100644
--- a/src/platform/mpfs_hal/startup_gcc/mss_entry.S
+++ b/src/platform/mpfs_hal/startup_gcc/mss_entry.S
@@ -1,10 +1,6 @@
 /*******************************************************************************
- * Copyright 2019-2020 Microchip Corporation.
- *
- * SPDX-License-Identifier: MIT
- *
- * MPFS HAL Embedded Software
- *
+ * See LICENSE for license details.
+ * Modifications copyright (C) 2021 Hex Five Security, Inc.
  */
 
 /*******************************************************************************
@@ -55,7 +51,7 @@ _start:
     csrw medeleg, 0
 .skip_e51:
     # mscratch must be init to zero- we are not using scratch memory
-    csrw mscratch, zero
+   #csrw mscratch, zero /* Hex Five Mod */
     csrw mcause, zero
     csrw mepc, zero
     /*
diff --git a/src/platform/mpfs_hal/startup_gcc/system_startup.c b/src/platform/mpfs_hal/startup_gcc/system_startup.c
index accd9ea..f4ffd54 100644
--- a/src/platform/mpfs_hal/startup_gcc/system_startup.c
+++ b/src/platform/mpfs_hal/startup_gcc/system_startup.c
@@ -105,7 +105,7 @@ __attribute__((weak)) int main_first_hart(void)
         hard_idx = MPFS_HAL_FIRST_HART + 1U;
         while( hard_idx <= MPFS_HAL_LAST_HART)
         {
-            uint32_t wait_count;
+            uint32_t wait_count=0;
 
             switch(sm_check_thread)
             {
